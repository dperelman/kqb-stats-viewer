<!doctype html>
<html>
  <head>
    <title>(Unofficial) Killer Queen Black JSON stats file viewer</title>
    <style type="text/css" >
body {
  background: #2b0e50;
  font-family: sans;
  color: white;
  margin: 0;
}
a {
  color: gold;
}
footer {
  margin: 1ex;
}
#github {
  position: absolute;
  top: 0;
  right: 0;
}
.navigation {
  text-align: center;
}
.navigation button {
  font-size: 3em;
}
#stats .winner {
  text-transform: uppercase;
  background: black;
  text-align: center;
  position: sticky;
  top: 0;
  z-index: 1;
}
#stats .gold-winner, #bglMatchName .gold {
  color: #ee914b;
  text-shadow: 0 0.07em 2px #b84d1f;
}
#stats .blue-winner, #bglMatchName .blue {
  color: #40c4f2;
  text-shadow: 0 0.07em 2px #495df1;
}
#stats .winner.unknown-winner {
  color: red;
}
#stats .winner::before, #stats .winner::after {
  margin: 0 1ex;
  text-shadow: none;
}
#stats .winner::before {
  color: #40c4f2;
  direction: rtl;
  unicode-bidi: bidi-override;
}
#stats .winner::after {
  color: #ee914b;
}
#stats .winner.blue-won-0::before, #stats .winner.gold-won-0::after {
  content: "â–¯â–¯â–¯";
}
#stats .winner.blue-won-1::before, #stats .winner.gold-won-1::after {
  content: "â–®â–¯â–¯";
}
#stats .winner.blue-won-2::before, #stats .winner.gold-won-2::after {
  content: "â–®â–®â–¯";
}
#stats .winner.blue-won-3::before, #stats .winner.gold-won-3::after {
  content: "â–®â–®â–®";
}

#stats .matchStats {
  display: grid;
  align-items: center;
}
#stats .matchStats .maps {
  grid-column: 1;
  position: sticky;
  top: 0;
}
#stats .matchStats .playerMatchStats {
  grid-column: 2;
}
#stats .matchStats .detailedStats {
  grid-column: 2;
}

#stats .map {
  margin: 3em 0;
}

#stats .map::before {
  margin-right: 0.5ex;
}
#stats .map.snail-victory::before {
  content: "ğŸŒ";
}
#stats .map.eco-victory::before {
  content: "ğŸ’";
}
#stats .map.mil-victory::before {
  content: "ğŸ—¡ï¸";
}

#stats .totalDuration::before {
  content: "â²ï¸";
}

.nickname::after {
  margin-left: 1ex;
}
.nickname.bot::after {
  content: "ğŸ¤–";
}
.nickname.league-0::after {
  content: "ğŸ¥‰";
}
.nickname.league-1::after {
  content: "ğŸ¥ˆ";
}
.nickname.league-2::after {
  content: "ğŸ¥‡";
}
.nickname.league-3::after {
  content: "â¬œ";
}
.nickname.league-4::after {
  content: "ğŸŒ‹âœ¨";
}

#stats .playerMatchStats, #stats .totalDuration {
  text-shadow: 0 0.1em 1px #854aea;
}

#stats .playerMatchStats .blue, #stats .playerMatchStats .gold {
  display: grid;
  margin: 2em;
}

#stats .playerMatchStats .player {
  grid-row: 1;
  width: 18ex;
  text-align: center;
}

#stats .playerMatchStats .identification {
  min-height: 7em;
  position: relative;
}

#stats .playerMatchStats .identification .rank {
  font-size: 0.9em;
}

#stats .playerMatchStats .identification .avatar {
  position: absolute;
  bottom: 0;
  width: 100%;
  font-size: 2em;
}
#stats .playerMatchStats .identification .avatar.queen::before {
  content: "ğŸ‘‘";
}
#stats .playerMatchStats .identification .avatar.worker::before {
  content: "ğŸ";
}
#stats .playerMatchStats .identification .avatar.worker.entitySkin-1::before {
  content: "ğŸ’ªğŸ";
}
#stats .playerMatchStats .identification .avatar.worker.entitySkin-2::before {
  content: "ğŸ¦“ğŸ";
}
#stats .playerMatchStats .identification .avatar.worker.entitySkin-3::before {
  content: "ğŸ’€ğŸ‘•ğŸ";
}
#stats .playerMatchStats .identification .avatar.worker.entitySkin-4::before {
  content: "ğŸª¢ğŸ";
}
#stats .playerMatchStats .identification .avatar.worker.entitySkin-5::before {
  content: "ğŸğŸ‘•ğŸ";
}

#stats .playerMatchStats .summaryStats {
  display: inline-grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  place-items: stretch;
  width: 100%;
  text-align: left;
}

#stats .playerMatchStats .summaryStats div {
  padding: 0.2em;
}

#stats .playerMatchStats .blue .summaryStats div {
  border: 3px solid #3fc1f6;
}

#stats .playerMatchStats .gold .summaryStats div {
  border: 3px solid #efc507;
}

#stats .playerMatchStats .summaryStats span {
  float: right;
  text-align: right;
}

#stats .playerMatchStats .blue, #stats .playerMatchStats .blue a {
  color: #03c9ee;
}
#stats .playerMatchStats .blue .summaryStats div {
  background: #4664dd;
}

#stats .playerMatchStats .gold, #stats .playerMatchStats .gold a {
  color: #ecc534;
}
#stats .playerMatchStats .gold .summaryStats div {
  background: #c3642b;
}

#stats .playerMatchStats .summaryStats .best {
  color: white;
  font-weight: bold;
}

#stats .playerMatchStats .summaryStats .kills {
  grid-row: 1;
  grid-column: 1;
  border-top-left-radius: 0.5em;
}
#stats .playerMatchStats .summaryStats .kills::before {
  content: "ğŸ—¡ï¸";
}
#stats .playerMatchStats .summaryStats .deaths {
  grid-row: 2;
  grid-column: 1;
  border-bottom-left-radius: 0.5em;
  border-top: 0 !important;
}
#stats .playerMatchStats .summaryStats .deaths::before {
  content: "ğŸ’€";
}
#stats .playerMatchStats .summaryStats .berries {
  grid-row: 1;
  grid-column: 2;
  border-top-right-radius: 0.5em;
  border-left: 0 !important;
}
#stats .playerMatchStats .summaryStats .berries::before {
  content: "ğŸ’";
}
#stats .playerMatchStats .summaryStats .snail {
  grid-row: 2;
  grid-column: 2;
  border-bottom-right-radius: 0.5em;
  border-top: 0 !important;
  border-left: 0 !important;
}
#stats .playerMatchStats .summaryStats .snail::before {
  content: "ğŸŒ";
}

#stats .detailSection {
  text-align: center;
}
#stats .detailedStats table {
  border-collapse: collapse;
  margin: auto;
}
#stats .detailedStats table td {
  text-align: center;
  padding: 0.2em;
  border-top: solid 4px #2b0e50;
  border-bottom: solid 4px #2b0e50;
  min-width: 5ex;
}
#stats .detailedStats table td.nickname {
  text-align: left;
  text-shadow: 0 0.1em 1px #854aea;
}
#stats .detailedStats table td.percentage {
  text-align: right;
}
#stats .detailedStats table td.na::before {
  content: "--";
}

#stats .detailedStats table .blank {
  background: none !important;
  border: none !important;
}
#stats .detailedStats table thead th {
  background: #6d15b4;
  vertical-align: bottom;
  border-top: 0;
}
#stats .detailedStats table thead tr.top th,
#stats .detailedStats table thead tr th.workerDeaths,
#stats .detailedStats table thead tr th.workerKills,
#stats .detailedStats table thead tr th.uptime {
  border-right: solid 4px #2b0e50;
}
#stats .detailedStats table thead tr.top th,
#stats .detailedStats table thead tr th.queenKills,
#stats .detailedStats table thead tr th.warriorDeaths,
#stats .detailedStats table thead tr th.berryDunks {
  border-left: solid 4px #2b0e50;
}
#stats .detailedStats table thead tr.bottom th,
#stats .detailedStats table thead tr th.snail {
  border-bottom: solid 4px #9a1cf7;
}
#stats .detailedStats table thead tr.top th {
  border-top-left-radius: 0.3em;
  border-top-right-radius: 0.3em;
}
#stats .detailedStats table thead th[colspan] {
  border-bottom: solid white;
}

#stats .detailedStats table tbody td.nickname {
  border-top-left-radius: 0.3em;
  border-bottom-left-radius: 0.3em;
}
#stats .detailedStats table tbody td.uptime {
  border-top-right-radius: 0.3em;
  border-bottom-right-radius: 0.3em;
}

#stats .detailedStats table tbody.blue td.nickname,
#stats .detailedStats table tbody.blue td.workerKills,
#stats .detailedStats table tbody.blue td.workerDeaths,
#stats .detailedStats table tbody.blue td.berryThrows,
#stats .detailedStats table tbody.blue td.snail {
  border-right: solid 3px #1666cd;
}
#stats .detailedStats table tbody.blue td.nickname {
  background: #1b2dac;
}
#stats .detailedStats table tbody.blue td {
  background: #2143b1;
}
#stats .detailedStats table tbody.blue td.warriorKills,
#stats .detailedStats table tbody.blue td.berryThrows,
#stats .detailedStats table tbody.blue td.uptime {
  background: #1145cf;
}
#stats .detailedStats table tbody.blue td.warriorDeaths {
  background: #0f2eb4;
}
#stats .detailedStats table tbody.blue td.workerDeaths,
#stats .detailedStats table tbody.blue td.snail {
  background: #142b9f;
}

#stats .detailedStats table tbody.gold td.nickname {
  background: #953c2f;
}
#stats .detailedStats table tbody.gold td.nickname,
#stats .detailedStats table tbody.gold td.workerKills,
#stats .detailedStats table tbody.gold td.workerDeaths,
#stats .detailedStats table tbody.gold td.berryThrows,
#stats .detailedStats table tbody.gold td.snail {
  border-right: solid 3px #ae6129;
}
#stats .detailedStats table tbody.gold td {
  background: #a7412f;
}
#stats .detailedStats table tbody.gold td.warriorKills,
#stats .detailedStats table tbody.gold td.berryThrows,
#stats .detailedStats table tbody.gold td.uptime {
  background: #ac4f2f;
}
#stats .detailedStats table tbody.gold td.warriorDeaths {
  background: #964029;
}
#stats .detailedStats table tbody.gold td.workerDeaths,
#stats .detailedStats table tbody.gold td.snail {
  background: #873718;
}

#showJson:checked ~ pre.rawJson {
  display: block;
}
pre.rawJson {
  display: none;
  overflow-x: scroll;
}
    </style>
    <script language="javascript" src="chart.min.js"></script>
    <script language="javascript" >
      const chartsEnabled = typeof Chart !== 'undefined';
      if (chartsEnabled) {
        Chart.defaults.borderColor = '#aaaaaa';
        Chart.defaults.color = 'white';

        class TimestampScale extends Chart.LinearScale {
          getLabelForValue(seconds) {
            const decimal = seconds - Math.floor(seconds);
            const decimalStr = decimal
                    .toLocaleString(undefined, { maximumFractionDigits: 2 })
                    .substring(1);
            return String(Math.floor(seconds / 60))
              + ":"
              + String(Math.floor(seconds % 60)).padStart(2, '0')
              + decimalStr
          }
        }
        TimestampScale.id = 'timestamp';
        Chart.register(TimestampScale);

        class SnailPositionScale extends Chart.LinearScale {
          getLabelForValue(pos) {
            return (pos > 0
                    ? 'gold '
                          + String(pos)
                    : pos < 0
                    ? 'blue '
                          + String(-pos)
                    : 'snail start');
          }
        }
        SnailPositionScale.id = 'snailPosition';
        Chart.register(SnailPositionScale);
      }

      let dir;
      let seenFiles;
      let currentFilename;
      let previousFilename;
      let nextFilename;
      let bglMatch = undefined;
      let bglSet = undefined;
      let teamIdMap = {};
      let playerIdMap = {};
      let playerNicknameMap = {};
      async function openFile() {
        let file;
        if (!window.showOpenFilePicker) {
          alert("Sorry, your web browser is unsupported. Try a recent build of Google Chrome/Chromium.");
        }
        [file] = await window.showOpenFilePicker({
          types: [
            {
              description: "JSON KQB stats file",
              accept: {
                "application/json": ['.json']
              }
            },
          ],
          excludeAcceptAllOption: true,
          multiple: false,
        });
        if (!file) return;

        dir = undefined;
        seenFiles = undefined;
        currentFilename = undefined;
        previousFilename = undefined;
        nextFilename = undefined;
        bglMatch = undefined;
        bglSet = undefined;
        teamIdMap = {};
        playerIdMap = {};
        playerNicknameMap = {};

        document.getElementById("dirhelp").style.display = "none";
        document.getElementById("filename").innerText = file.name;
        displayStats(JSON.parse(await (await file.getFile()).text()));
      }
      async function openDir() {
        if (!window.showDirectoryPicker) {
          alert("Sorry, your web browser is unsupported. Try a recent build of Google Chrome/Chromium.");
        }
        dir = await window.showDirectoryPicker();
        if (dir) {
          // From https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload
          // Make reload show a confirmation if a directory is loaded.
          window.addEventListener('beforeunload', function (e) {
            // Cancel the event
            e.preventDefault(); // If you prevent default behavior in Mozilla Firefox prompt will always be shown
            // Chrome requires returnValue to be set
            e.returnValue = '';
          });

          bglMatch = undefined;
          bglSet = undefined;
          teamIdMap = {};
          playerIdMap = {};
          playerNicknameMap = {};

          document.getElementById("dirhelp").style.display = "none";
          document.getElementById("navigation").style.display = "";
          document.getElementById("bglNavigation").style.display = "none";
          seenFiles = new Map();
          previousFilename = undefined;
          nextFilename = undefined;
          currentFilename = undefined;
          document.getElementById('latest').disabled = false;
          loadLatest();
        }
      }
      async function refreshDir() {
        const newFiles = new Map();
        for await (const entry of dir.values()) {
          if (!seenFiles.has(entry.name)) {
            const timestamp = (await entry.getFile()).lastModified;
            newFiles.set(entry.name, timestamp);
            seenFiles.set(entry.name, timestamp);
          }
        }

        return newFiles;
      }
      async function loadByFilename(filename) {
        document.getElementById("filename").innerText = filename;

        currentFilename = filename;
        const currentTimestamp = seenFiles.get(filename);
        const prevFiles = Array.from(seenFiles.entries())
                          .filter(f => f[1] < currentTimestamp)
        previousFilename = prevFiles.length == 0
                ? undefined
                : prevFiles.reduce((a, b) => a[1]>b[1] ? a : b)[0]
        document.getElementById("prev").disabled = !previousFilename;
        const nextFiles = Array.from(seenFiles.entries())
                          .filter(f => f[1] > currentTimestamp)
        nextFilename = nextFiles.length == 0
                ? undefined
                : nextFiles.reduce((a, b) => a[1]<b[1] ? a : b)[0]
        document.getElementById("next").disabled = !nextFilename;

        const file = await dir.getFileHandle(filename);
        displayStats(JSON.parse(await (await file.getFile()).text()));
      }
      async function loadLatest() {
        const newFiles = await refreshDir();
        const files = newFiles.size > 0 ? newFiles : seenFiles;
        loadByFilename(Array.from(files.entries()).reduce((a, b) => a[1]>b[1] ? a : b)[0]);
      }
      async function loadNext() {
        loadByFilename(nextFilename);
      }
      async function loadPrevious() {
        loadByFilename(previousFilename);
      }

      async function loadBglMatch(matchId) {
        const bglMatchResponse = await fetch("https://api.beegame.gg/matches/"
                                             + matchId + "/?format=json");
        const match = await bglMatchResponse.json();
        await loadBglResults(match.result.id, match)
      }
      async function loadBglResults(resultsId, matchInfo) {
        const bglMatchResponse = await fetch("https://api.beegame.gg/results/"
                                             + resultsId + "/?format=json");
        bglMatch = await bglMatchResponse.json();

        if (!matchInfo) {
          const bglMatchInfoResponse = await fetch(
                "https://api.beegame.gg/matches/"
                + bglMatch.match + "/?format=json");
          matchInfo = await bglMatchInfoResponse.json();
        }

        teamIdMap = {};
        playerIdMap = {};
        playerNicknameMap = {};

        async function loadPlayer(playerId) {
          const bglPlayerResponse = await fetch(
                  "https://api.beegame.gg/players/"+ playerId
                  + "/?format=json");
          return await bglPlayerResponse.json();
        }
        const playersPromise = Promise.all(bglMatch.player_mappings.map(
                p => loadPlayer(p.player)));

        const firstGame = bglMatch.sets[0].games[0];
        teamIdMap[firstGame.winner.id] = firstGame.winner;
        teamIdMap[firstGame.loser.id] = firstGame.loser;

        const teamMap = {2: "blue", 1: "gold"};
        const teamColorMap = {};
        for (const mapping of bglMatch.team_mappings) {
          teamColorMap[teamMap[mapping.color]] = mapping.team;
        }
        const blueTeam = teamIdMap[teamColorMap["blue"]]
        const goldTeam = teamIdMap[teamColorMap["gold"]]

        document.getElementById("dirhelp").style.display = "none";
        document.getElementById("navigation").style.display = "none";
        document.getElementById("bglNavigation").style.display = "";

        const matchName = document.getElementById("bglMatchName");
        while (matchName.firstChild) {
          matchName.removeChild(matchName.lastChild);
        }
        const teamNodes = {};
        for (const color of ["blue", "gold"]) {
          const teamNode = document.createElement("a");
          teamNode.classList.add(color);
          const team = teamIdMap[teamColorMap[color]];
          teamNode.href = "https://league.beegame.gg/teams/" + team.id + "/";
          const setsWon = bglMatch.sets.filter(set => set.winner == team.id)
                                       .length;
          teamNode.innerText = team.name
                  + (bglMatch.winner == team.id ? "ğŸ†" : "")
                  + " ("
                  + setsWon
                  + ")";
          teamNodes[color] = teamNode;
        }
        matchName.appendChild(document.createTextNode(
                matchInfo.circuit.season.name + ": "));
        const tierLink = document.createElement("a");
        tierLink.href = "https://league.beegame.gg/circuits/"
                        + matchInfo.circuit.id + "/";
        tierLink.innerText = matchInfo.circuit.name;
        matchName.appendChild(tierLink);
        matchName.appendChild(document.createTextNode(
                ": " + matchInfo.round.name + ": "));
        matchName.appendChild(teamNodes["blue"]);
        matchName.appendChild(document.createTextNode(" vs. "));
        matchName.appendChild(teamNodes["gold"]);
        matchName.appendChild(document.createTextNode(
                " (" + new Date(matchInfo.start_time).toLocaleString() + ")"));

        const playersList = await playersPromise;
        for (const player of playersList) {
          playerIdMap[player.id] = player;
        }
        for (const mapping of bglMatch.player_mappings) {
          playerNicknameMap[mapping.nickname] = playerIdMap[mapping.player];
        }

        loadBglSet(0);
      }
      function loadBglSet(num) {
        const numSets = bglMatch.sets.length;
        if (num < 0 || num >= numSets) return;
        bglSet = num;

        document.getElementById("prevBgl").disabled = bglSet == 0;
        document.getElementById("nextBgl").disabled = bglSet == numSets - 1;

        document.getElementById("filename").innerText = "Set " + (bglSet+1)
                                                        + "/" + numSets;
        displayStats(bglMatch.sets[bglSet].log.body);
      }
      function loadNextBgl() {
        loadBglSet(bglSet + 1);
      }
      function loadPreviousBgl() {
        loadBglSet(bglSet - 1);
      }

      function displayStats(stats) {
        const div = document.getElementById("stats");
        while (div.firstChild) div.removeChild(div.lastChild);

        const header = document.createElement("h2");
        header.classList.add("winner");
        const goldWins = stats.gameWinners.filter(v => v == 1).length;
        const blueWins = stats.gameWinners.filter(v => v == 2).length;
        header.classList.add("gold-won-" + goldWins);
        header.classList.add("blue-won-" + blueWins);
        if (goldWins == 3) {
          header.classList.add("gold-winner");
          header.innerText = "Gold wins";
        } else if (blueWins == 3) {
          header.classList.add("blue-winner");
          header.innerText = "Blue wins";
        } else {
          header.classList.add("unknown-winner");
          header.innerText = "Incomplete match?";
        }
        div.appendChild(header);

        const teams = ["blue", "gold"];
        const teamMap = {2: "blue", 1: "gold"};
        const players = {};
        for (const team of [2, 1]) {
          const teamName = teamMap[team];
          // queens first
          players[teamName] =
            stats.playerMatchStats
                 .filter(p => p.team == team && p.entityType == 3)
                .concat(stats.playerMatchStats
                 .filter(p => p.team == team && p.entityType != 3))
                .map(p => p.nickname);
        }

        const majorStats = ["kills", "berries", "deaths", "snail"];
        const best = {};
        for (const stat of majorStats) {
          const f = (stat == "deaths" ? Math.min : Math.max);
          best[stat] = f(...stats.playerMatchStats.map(p => p[stat]));
        }

        const matchStats = document.createElement("div");
        matchStats.classList.add("matchStats");

        const maps = document.createElement("ol");
        maps.classList.add("maps");

        const mapNames = {
          2:  "Pod",
          4:  "BQK",
          7:  "Helix",
          11: "Tally",
          14: "Spire",
          15: "Split",
          17: "Nest",
          18: "Throne",
        }
        const winNames ={
          1: "Mil",
          2: "Eco",
          3: "Snail",
        }

        for (let i = 0; i < stats.mapPool.length; i++) {
          const map = document.createElement("li");
          map.classList.add("map");
          map.classList.add("map-" + mapNames[stats.mapPool[i]].toLowerCase());
          if (i in stats.gameWinners) {
            map.classList.add(teamMap[stats.gameWinners[i]] + "-winner");
            map.classList.add(winNames[stats.winConditions[i]].toLowerCase()
                              + "-victory");
            const time = Math.floor(stats.games[i].duration / 60) + ":"
                         + String(Math.floor(stats.games[i].duration % 60))
                           .padStart(2, '0');
            map.innerText = mapNames[stats.mapPool[i]]
                            + " (" + time + ")";
          } else {
            map.innerText = mapNames[stats.mapPool[i]];
          }
          maps.appendChild(map);
        }

        const totalTime = document.createElement("div");
        totalTime.classList.add("totalDuration");
        const totalDuration = stats.games.map(g => g.duration)
                                         .reduce((a, b) => a + b);
        totalTime.innerText = String(Math.floor(totalDuration / 60))
                              .padStart(2, '0') + ":"
                              + String(Math.floor(totalDuration % 60))
                                .padStart(2, '0');
        maps.appendChild(totalTime);

        matchStats.appendChild(maps);

        const playerMatchStats = document.createElement("div");
        playerMatchStats.classList.add("playerMatchStats");
        for (const team of teams) {
          const teamMatchStats = document.createElement("div");
          teamMatchStats.classList.add(team);

          for (const nickname of players[team]) {
            const playerStats = stats.playerMatchStats
                                .filter(p => p.nickname == nickname)[0];
            const profiles = stats.profiles
                             .filter(p => p.displayName == nickname);
            const profile = profiles.length == 0 ? undefined : profiles[0];

            const player = document.createElement("div");
            player.classList.add("player");

            const identification = document.createElement("div");
            identification.classList.add("identification");

            const nameDiv = document.createElement("div");
            nameDiv.classList.add("nickname");
            if (playerStats.nickname == playerStats.playerId) {
              nameDiv.classList.add("bot");
            } else if (profile && profile.currentLeague >= 0) {
              nameDiv.classList.add("league-" + profile.currentLeague);
            }
            if (nickname in playerNicknameMap) {
              const player = playerNicknameMap[nickname];
              const nameLink = document.createElement("a");
              nameLink.innerText = player.name;
              nameLink.href = "https://league.beegame.gg/player/"
                              + player.id + "/";
              nameDiv.appendChild(nameLink);
            }
            else {
              nameDiv.innerText = nickname;
            }
            identification.appendChild(nameDiv);

            if (document.getElementById("filename").innerText
                .startsWith("Ranked-") && profile) {
              const rank = document.createElement("div");
              rank.classList.add("rank");

              rank.innerText = profile.currentLeague == -1
                    ? "placement: " + profile.placementRecord.win + "-"
                      + profile.placementRecord.loss
                    : profile.rankedRankingData.roundedRating + " ("
                      + (profile.rankingAdjustment > 0 ? "+" : "")
                      + profile.rankingAdjustment + ")";

              identification.appendChild(rank);
            }

            const avatar = document.createElement("div");
            avatar.classList.add("avatar");
            avatar.classList.add("entitySkin-" + playerStats.entitySkin);
            avatar.classList.add("entityType-" + playerStats.entityType);
            avatar.classList.add(playerStats.entityType == 3
                                  ? "queen"
                                  : "worker");
            identification.appendChild(avatar);
            player.appendChild(identification);

            const summaryStats = document.createElement("div");
            summaryStats.classList.add("summaryStats");
            for (const statName of majorStats) {
              const statDisplay = document.createElement("div");
              statDisplay.classList.add(statName);
              const statValue = document.createElement("span");
              statValue.innerText = playerStats[statName];
              statDisplay.appendChild(statValue);
              if (playerStats[statName] == best[statName]) {
                statDisplay.classList.add("best");
              }
              summaryStats.appendChild(statDisplay);
            }
            player.appendChild(summaryStats);

            teamMatchStats.appendChild(player);
          }

          playerMatchStats.appendChild(teamMatchStats);
        }
        matchStats.appendChild(playerMatchStats);

        const detailedStats = document.createElement("div");
        detailedStats.classList.add("detailedStats");

        detailedStatsInfo = [
          {
            class: "queenKills",
            property: "totalQueenKillCount",
            queen: true,
          },
          {
            class: "warriorKills",
            property: "totalWarriorKillCount",
            queen: true,
          },
          {
            class: "workerKills",
            property: "totalWorkerKillCount",
            queen: true,
          },
          {
            class: "warriorDeaths",
            property: "warriorAndQueenDeathCount",
            queen: true,
          },
          {
            class: "workerDeaths",
            property: "workerDeathCount",
            queen: false,
          },
          {
            class: "berryDunks",
            property: "totalBerryDeposits",
            queen: false,
            omitForQueen: true,
          },
          {
            class: "berryThrows",
            property: "totalBerryThrowIns",
            queen: 2,
          },
          {
            class: "snail",
            property: "totalSnailDistance",
            queen: false,
          },
          {
            class: "gates",
            property: undefined,
            queen: true,
            percentage: true,
          },
          {
            class: "uptime",
            property: "timeSpentAsWarriorSeconds",
            queen: false,
            percentage: true,
          },
        ];

        const gateDurations = stats.games.map(g => {
          const res = {};
          for (let team of teams) {
            const gateProperty = team == "blue" ? "timeAsBlue" : "timeAsRed";
            res[team] = g.gateControls.map(a => a[gateProperty])
                                      .reduce((a, b) => a + b);
          }
          res["total"] = res["blue"] + res["gold"];
          return res;
        });

        for (let i = -1; i < stats.games.length; i++) {
          const detailSection = document.createElement("div");
          detailSection.classList.add("detailSection");
          const detailTitle = document.createElement("h3");
          detailTitle.innerText = i == -1 ? "Entire set" : "Map " + (i+1);
          detailSection.appendChild(detailTitle);
          const detailTemplate = document.querySelector("#detailedStats")
                                 .content.cloneNode(true);
          if (i == -1 || !chartsEnabled) {
            detailTemplate.removeChild(
                    detailTemplate.querySelector(".mapCharts"));
          }
          const detailTable = detailTemplate.querySelector("table");
          detailSection.appendChild(detailTemplate);
          detailedStats.appendChild(detailSection);

          const duration = i == -1 ? totalDuration : stats.games[i].duration;
          const gateTotalDuration = i == -1
            ? gateDurations.map(g => g["total"]).reduce((a, b) => a + b)
            : gateDurations[i]["total"];

          for (const team of teams) {
            const tbody = document.createElement("tbody");
            tbody.classList.add(team);

            const teamTotals = {};
            for (let detail of detailedStatsInfo) {
              if (detail.property) {
                teamTotals[detail.property] = 0;
              }
            }
            if (i == -1) {
              teamTotals["gates"] = gateDurations.map(g => g[team])
                                                 .reduce((a, b) => a + b);
            } else {
              teamTotals["gates"] = gateDurations[i][team];
            }
            teamTotals["workers"] = 0;

            for (const nickname of players[team]) {
              let gameStats;
              if (i == -1) {
                const allGameStats =
                        stats.games.flatMap(g => g.playerStats)
                                   .filter(s => s.nickname == nickname);
                gameStats = {}
                for (const detail of detailedStatsInfo) {
                  if (detail.property) {
                    gameStats[detail.property] =
                            allGameStats.map(s => s[detail.property])
                                        .reduce((a, b) => a + b);
                  }
                }
                gameStats["entityType"] = allGameStats[0].entityType;
              } else {
                const gameStatsList = stats.games[i].playerStats
                                      .filter(s => s.nickname == nickname);
                if (gameStatsList.length == 0) continue;
                gameStats = gameStatsList[0];
              }

              const playerIsQueen = gameStats.entityType == 3;
              if (!playerIsQueen) teamTotals["workers"]++;

              const row = document.createElement("tr");
              row.classList.add("playerRow");

              const nameCell = document.createElement("td");
              nameCell.classList.add("nickname");
              if (nickname in playerNicknameMap) {
                const player = playerNicknameMap[nickname];
                nameCell.innerText = player.name;
              }
              else {
                nameCell.innerText = nickname;
              }
              row.appendChild(nameCell);

              for (let detail of detailedStatsInfo) {
                if (detail.property) {
                  teamTotals[detail.property] += gameStats[detail.property];
                }

                const cell = document.createElement("td");
                cell.classList.add(detail.class);
                if (!(playerIsQueen && "omitForQueen" in detail)) {
                  row.appendChild(cell);
                }
                if (detail.percentage) cell.classList.add("percentage");
                if (!detail.queen && playerIsQueen
                    || !detail.property && !playerIsQueen) {
                  cell.classList.add("na");
                  continue;
                }
                if (playerIsQueen && detail.queen && detail.queen !== true) {
                  cell.colSpan = detail.queen;
                }
                if (detail.percentage) {
                  const totalSeconds = detail.property
                          ? gameStats[detail.property]
                          : teamTotals["gates"];
                  const denominator = detail.property
                        ? duration
                        : gateTotalDuration
                  const percentage = totalSeconds == 0 || denominator == 0
                        ? 0
                        : Math.round(totalSeconds / denominator * 1000) / 10;
                  cell.innerText = (percentage == 0
                                    ? 0
                                    : percentage.toFixed(1))
                                   + '%';
                } else {
                  cell.innerText = detail.property == "totalBerryDeposits"
                        ? gameStats[detail.property]
                            - gameStats["totalBerryThrowIns"]
                        : gameStats[detail.property];
                }
              }

              tbody.appendChild(row);
            }
            const totalRow = document.createElement("tr");
            totalRow.classList.add("total");

            const blank = document.createElement("td");
            blank.classList.add("blank");
            totalRow.appendChild(blank);
            for (let detail of detailedStatsInfo) {
              const cell = document.createElement("td");
              cell.classList.add(detail.class);
              totalRow.appendChild(cell);

              if (detail.percentage) {
                cell.classList.add("percentage");
                const totalSeconds = detail.property
                      ? (teamTotals["workers"] == 0
                        ? 0
                        : teamTotals[detail.property] / teamTotals["workers"])
                      : teamTotals["gates"];
                const denominator = detail.property
                      ? duration
                      : gateTotalDuration
                const percentage = totalSeconds == 0 || denominator == 0
                      ? 0
                      : Math.round(totalSeconds / denominator * 1000) / 10;
                cell.innerText = (percentage == 0
                                  ? 0
                                  : percentage.toFixed(1))
                                 + '%';
              } else {
                cell.innerText = detail.property == "totalBerryDeposits"
                      ? teamTotals[detail.property]
                          - teamTotals["totalBerryThrowIns"]
                      : teamTotals[detail.property];
              }
            }
            tbody.appendChild(totalRow);

            detailTable.appendChild(tbody);
          }

          if (i != -1 && chartsEnabled) {
            const game = stats.games[i];
            const chartCtx = detailSection
                             .querySelector(".mapCharts canvas.mapChart");
            const mapChart = new Chart(chartCtx, {
              type: 'line',
              data: {
                datasets: [
                  {
                    type: 'line',
                    label: 'Snail position',
                    data: game.snailPosition,
                    borderColor: "#f016d7",
                    backgroundColor: "#f016d7",
                    yAxisID: 'snail',
                    parsing: {
                      xAxisKey: 'time',
                      yAxisKey: 'count',
                    }
                  },
                  {
                    type: 'line',
                    label: 'Blue berries',
                    data: game.blueBerryCount,
                    borderColor: "#1666cd",
                    backgroundColor: "#1666cd",
                    stepped: true,
                    yAxisID: 'berries',
                    parsing: {
                      xAxisKey: 'time',
                      yAxisKey: 'count',
                    }
                  },
                  {
                    type: 'line',
                    label: 'Gold berries',
                    data: game.goldBerryCount,
                    borderColor: "#ae6129",
                    backgroundColor: "#ae6129",
                    stepped: true,
                    yAxisID: 'berries',
                    parsing: {
                      xAxisKey: 'time',
                      yAxisKey: 'count',
                    }
                  },
                  {
                    type: 'line',
                    label: 'Blue warriors up',
                    data: game.blueWarriorsUp,
                    borderColor: "#2143b1",
                    backgroundColor: "#2143b1",
                    stepped: true,
                    yAxisID: 'warriorsUp',
                    parsing: {
                      xAxisKey: 'time',
                      yAxisKey: 'count',
                    }
                  },
                  {
                    type: 'line',
                    label: 'Gold warriors up',
                    data: game.goldWarriorsUp,
                    borderColor: "#a7412f",
                    backgroundColor: "#a7412f",
                    stepped: true,
                    yAxisID: 'warriorsUp',
                    parsing: {
                      xAxisKey: 'time',
                      yAxisKey: 'count',
                    }
                  },
                  {
                    type: 'scatter',
                    label: 'Blue queen deaths',
                    data: game.goldQueenKillTimes
                          .map((time, idx) => ({x: time, y: 1, r: idx+1})),
                    borderColor: "#1b2dac",
                    backgroundColor: "#1b2dac",
                    yAxisID: 'queenKills',
                    radius: 10,
                  },
                  {
                    type: 'scatter',
                    label: 'Gold queen deaths',
                    data: game.blueQueenKillTimes
                          .map((time, idx) => ({x: time, y: 1, r: idx+1})),
                    borderColor: "#953c2f",
                    backgroundColor: "#953c2f",
                    yAxisID: 'queenKills',
                    radius: 10,
                  },
                ],
              },
              options: {
                responsive: true,
                interaction: {
                  intersect: false,
                },
                plugins: {
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        if (context.dataset.yAxisID === "queenKills") {
                          return context.dataset.label.slice(0, -1)
                                  + " #" + context.raw.r;
                        }

                        let label = context.dataset.label || '';

                        if (label) {
                          label += ': ';
                        }
                        if (context.parsed.y !== null) {
                          label += context.formattedValue;
                        }
                        return label;
                      },
                    },
                  },
                },
                stacked: false,
                scales: {
                  x: {
                    type: 'timestamp',
                    display: true,
                    position: 'bottom',
                    axis: 'x',
                    min: 0,
                    max: game.duration,
                    ticks: {
                      stepSize: 15,
                      callback: seconds => String(Math.floor(seconds / 60))
                        + ":"
                        + String(Math.floor(seconds % 60)).padStart(2, '0')
                    },
                  },
                  snail: {
                    title: "Snail Position (up is gold, down is blue)",
                    type: 'snailPosition',
                    display: true,
                    position: 'left',
                    axis: 'y',
                    min: game.blueSnailGatePos,
                    max: game.goldSnailGatePos,
                    ticks: {
                      callback: (pos, index, ticks) => (pos > 0
                          ? 'gold '
                                + (pos == game.goldSnailGatePos ? 'goal ' : '')
                                + String(pos)
                          : pos < 0
                          ? 'blue '
                                + (pos == game.blueSnailGatePos ? 'goal ' : '')
                                + String(-pos)
                          : 'snail start'),
                      color: function(context) {
                        const value = context.tick.value;
                        return value > 0
                                ? '#ee914b'
                                : value < 0
                                ? '#40c4f2'
                                : 'white';
                      },
                    },
                  },
                  berries: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    axis: 'y',
                    min: 0,
                    max: game.berriesNeeded,
                    ticks: {
                      stepSize: 2,
                      callback: num => num + ' ğŸ’'
                    },
                    grid: {
                      drawOnChartArea: false,
                    },
                  },
                  warriorsUp: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    axis: 'y',
                    min: 0,
                    max: 3,
                    ticks: {
                      stepSize: 1,
                      callback: num => num + ' âš”ï¸'
                    },
                    grid: {
                      drawOnChartArea: false,
                    },
                  },
                  queenKills: {
                    type: 'linear',
                    display: false,
                    position: 'right',
                    axis: 'y',
                    min: 0,
                    max: 1,
                    ticks: {
                      stepSize: 1,
                    },
                    grid: {
                      drawOnChartArea: false,
                    },
                  },
                  y: {
                    display: false,
                  },
                }
              }
            });
          }
        }

        matchStats.appendChild(detailedStats);
        div.appendChild(matchStats);

        const showJson = document.createElement("input");
        showJson.id = "showJson";
        showJson.type = "checkbox";
        div.appendChild(showJson);

        const showJsonLabel = document.createElement("label");
        showJsonLabel.innerText = "Show raw JSON";
        showJsonLabel.htmlFor = "showJson";
        div.appendChild(showJsonLabel);

        const jsonDisplay = document.createElement("pre");
        jsonDisplay.classList.add("rawJson");
        jsonDisplay.innerText = JSON.stringify(stats, null, 2);
        div.appendChild(jsonDisplay);
      }

      window.onload = function() {
        const hash = window.location.hash;
        const match = hash.match(/^#bgl(results)?id=(?<bglid>\d+)$/i);
        if (match) {
          loadBglResults(match.groups.bglid);
        }
        const match2 = hash.match(/^#bglMatchId=(?<bglmatchid>\d+)$/i);
        if (match2) {
          loadBglMatch(match2.groups.bglmatchid);
        }
      }
    </script>
    <template id="detailedStats">
      <table>
        <thead>
          <tr class="top">
            <th class="blank"></th>
            <th colspan="3" class="kills">ğŸ—¡ï¸</th>
            <th colspan="2" class="deaths">ğŸ’€</th>
            <th colspan="2" class="berries">ğŸ’</th>
            <th rowspan="2" class="snail">ğŸŒ</th>
            <th colspan="2" class="uptime">â²ï¸</th>
          </tr>
          <tr class="bottom">
            <th class="blank"></th>
            <th class="queenKills">ğŸ‘‘</th>
            <th class="warriorKills">âš”ï¸</th>
            <th class="workerKills">ğŸ</th>
            <th class="warriorDeaths">ğŸ‘‘/âš”ï¸</th>
            <th class="workerDeaths">ğŸ</th>
            <th class="berryDunks" title="dunked berries">ğŸ€</th>
            <th class="berryThrows" title="thrown berries">â†·</th>
            <th class="gates" title="gate control">â›©ï¸</th>
            <th class="uptime" title="warrior uptime">âš”ï¸</th>
          </tr>
        </thead>
      </table>
      <div class="mapCharts">
        <canvas class="mapChart"></canvas>
      </div>
    </template>
  </head>
  <body>
    <a id="github" href="https://github.com/dperelman/kqb-stats-viewer">
      Report issues or submit pull requests on GitHub
    </a>
    <button id="openDir" onclick="openDir()">Open directory</button>
    <button id="open" onclick="openFile()">Open file</button>
    <a href="bgl-browser.html" target="_blank">BGL match browser</a>
    <div id="dirhelp">
      <h1>How to use</h1>
      <p>
        (Unfortunately, Google Chrome/Chromium is required;
        Firefox does not support the "open directory" API.)
      </p>
      <p>
        To view your Killer Queen Black stats, select your
        <tt>match-stats</tt> directory. Copy the directory below corresponding
        to your OS, click the "Open directory" button the top-left
        and paste that in to the directory selection dialog.
        You will be asked to confirm that you want to grant
        "view files" permissions on that directory.
        This page will never modify your stats files
        or ask for permissions to do, and works entirely locally
        (i.e., your stats are not sent to a server).
      </p>
      <p>
        After a match completes (e.g., while you're in queue),
        you can click the "Jump to Newest" button to view the stats
        for the most recent match. You can also use the "Previous"/"Next"
        buttons to navigate through your older matches or select a specific
        stats file with the "Open file" button.
      </p>
      <p>
        You can post feedback on
        <a href = "https://github.com/dperelman/kqb-stats-viewer">GitHub</a>
        or contact me at <tt>aebonyne#2493</tt> on Discord.
      </p>
      <h2>Default directories:</h2>
      <dl>
        <dt>Windows</dt>
        <dd>%USERPROFILE%\AppData\LocalLow\Liquid Bit, LLC\Killer Queen Black\match-stats</dd>
        <dt>Mac</dt>
        <dd>?</dd>
        <dt>Linux (Steam Play/Proton)</dt>
        <dd>~/.local/share/Steam/steamapps/compatdata/663670/pfx/drive_c/users/steamuser/AppData/LocalLow/Liquid Bit, LLC/Killer Queen Black/match-stats/</dd>
      </dl>
    </div>
    <div id="navigation" class="navigation" style="display:none;">
      <button id="prev" onclick="loadPrevious()" disabled>&lt; Previous</button>
      <button id="next" onclick="loadNext()" disabled>Next &gt;</button>
      <button id="latest" onclick="loadLatest()" disabled>Jump to Newest â‡‰</button>
    </div>
    <div id="bglNavigation" class="navigation" style="display:none;">
      <h1 id="bglMatchName"></h1>
      <button id="prevBgl" onclick="loadPreviousBgl()" disabled>&lt; Previous Set</button>
      <button id="nextBgl" onclick="loadNextBgl()" disabled>Next Set &gt;</button>
    </div>
    <h1 id="matchName"><span id="filename"></span></h1>
    <div id="stats"></div>
    <footer>
      This is an unofficial tool for viewing the JSON stats files generated
      at the end of every match by the Windows version of
      <a href = "http://www.killerqueenblack.com/">Killer Queen Black</a>.
    </footer>

  </body>
</html>

